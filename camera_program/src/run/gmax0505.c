#include "gmax0505.h"

#include "gpio.h"

/* FreeRTOS includes. */
#include "FreeRTOS.h"

const uint8_t gmax_config[256] = {0x22, 0x05, 0x00, 0xF4, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x14, 0x01, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x14, 0x00, 0x00, 0x06, 0x02, 0x02, 0x04, 0x04, 0x00, 0x20, 0x23, 0x01, 0xc4, 0x35, 0xcb, 0x3b, 0x35, 0xfc, 0xff, 0xff, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x34, 0xD8, 0x10, 0x4F, 0x3D, 0x00, 0x08, 0x90, 0xC0, 0x1D, 0x09, 0xC4, 0x32, 0x4B, 0x5B, 0x05, 0xD0, 0xA0, 0xC3, 0x44, 0x02, 0x10, 0x70, 0x43, 0x0E, 0x30, 0xD0, 0xF0, 0xD0, 0x44, 0x07, 0xD0, 0xC0, 0xC3, 0x44, 0x34, 0xF0, 0x80, 0xC3, 0xFF, 0x4B, 0xA4, 0xA1, 0x40, 0x0E, 0x41, 0xFC, 0x1F, 0x81, 0x0C, 0x7C, 0x00, 0x18, 0x1B, 0x01, 0x00, 0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x07, 0xD0, 0xC0, 0xC3, 0x44, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x1B, 0x21, 0x80, 0xF1, 0x83, 0x84, 0x95, 0xCC, 0x77, 0xF3, 0xDD, 0x0D, 0xD3, 0x00, 0x00, 0x1C, 0xB0, 0x0D, 0xFE, 0x62, 0xC1, 0x1F, 0x8A, 0xCA, 0xE7, 0xA8, 0x3C, 0xCA, 0xFE, 0x82, 0x34, 0x7F, 0xC1, 0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static void write_data_bit(bool value)
{
    gpio_write(SEN_SPI_MOSI, value);
    gpio_reset(SEN_SPI_CLK);
    gpio_set(SEN_SPI_CLK);
}

static void write_data_byte(uint8_t value)
{
    for (uint8_t i = 0; i < 8; i++)
    {
        write_data_bit(value & (1 << (7 - i)));
    }
}

static bool read_data_bit()
{
    gpio_reset(SEN_SPI_CLK);
    gpio_set(SEN_SPI_CLK);
    return gpio_read(SEN_SPI_MISO);
}

static uint8_t read_data_byte()
{
    uint8_t value = 0;

    for (uint8_t i = 0; i < 8; i++)
    {
        value |= read_data_bit() << (7 - i);
    }

    return value;
}

static void gmax_delay_ms(uint32_t time_ms)
{
    vTaskDelay(pdMS_TO_TICKS(time_ms));
}

void gmax_power_on()
{
    gpio_reset(SEN_SYS_NRESET);
    gmax_delay_ms(10);
    gpio_set(PWR_SEN_1V3_EN);
    gmax_delay_ms(10);
    gpio_set(PWR_SEN_3V3A_EN);
    gmax_delay_ms(10);
    gpio_set(PWR_SEN_3V6_EN);
    gpio_set(PWR_SEN_4V1_EN);
    gmax_delay_ms(10);
    gpio_set(PWR_SEN_0V7_EN);
    gmax_delay_ms(10);
    gpio_set(PWR_SEN_N1V3A_EN);
    gmax_delay_ms(10);
    gpio_set(SEN_SYS_NRESET);
}

void gmax_power_off()
{
    gpio_reset(SEN_SYS_NRESET);
    gmax_delay_ms(10);
    gpio_reset(PWR_SEN_N1V3A_EN);
    gmax_delay_ms(10);
    gpio_reset(PWR_SEN_0V7_EN);
    gmax_delay_ms(10);
    gpio_reset(PWR_SEN_3V6_EN);
    gpio_reset(PWR_SEN_4V1_EN);
    gmax_delay_ms(10);
    gpio_reset(PWR_SEN_3V3A_EN);
    gmax_delay_ms(10);
    gpio_reset(PWR_SEN_1V3_EN);
}

void gmax_spi_write(uint8_t reg, uint8_t *data, uint32_t len)
{
    // Select is active high
    gpio_set(SEN_SPI_NCS);

    // Do the RW bit (1 for write)
    write_data_bit(true);

    // Output the register address
    write_data_byte(reg);

    // Clock the data out
    for (uint32_t i = 0; i < len; i++)
    {
        write_data_byte(&data[i]);
    }

    // Finish with reseting the select line
    gpio_reset(SEN_SPI_NCS);
}

void gmax_spi_read(uint8_t reg, uint8_t *data, uint32_t len)
{
    // Select is active high
    gpio_set(SEN_SPI_NCS);

    // Do the RW bit (0 for read)
    write_data_bit(false);

    // Output the register address
    write_data_byte(reg);

    // Need a dummy bit
    write_data_bit(false);

    // Clock the data out
    for (uint32_t i = 0; i < len; i++)
    {
        data[i] = read_data_byte();
    }

    // Finish with reseting the select line
    gpio_reset(SEN_SPI_NCS);
}

void gmax_init()
{
    gmax_power_on();

    // Write config with streaming off and reg 209[3:0] = 0100
    gmax_spi_write(0x00, (uint8_t *)gmax_config, 256);

    // Wait 1ms
    gmax_delay_ms(1);

    // Now set reg 209[3:0] to 0000
    uint8_t value = gmax_config[209] & 0xF0;
    gmax_spi_write(209, &value, 1);

    // Wait 5ms
    gmax_delay_ms(5);

    // Now enable streaming
    value = gmax_config[0] | 0x01;
    gmax_spi_write(0x00, &value, 1);
}